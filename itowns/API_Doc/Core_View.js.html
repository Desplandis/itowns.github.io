<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>iTowns API : Core/View.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="./styles/itowns.css">
</head>

<body>

    <div id="main">

        <p></p>
        <div class="page-title"><img src="https://raw.githubusercontent.com/iTowns/itowns.github.io/master/images/itowns_logo_300x134.png" /></div>

        



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/* global window */
import * as THREE from 'three';
import Camera from '../Renderer/Camera';
import MainLoop, { MAIN_LOOP_EVENTS, RENDERING_PAUSED } from './MainLoop';
import c3DEngine from '../Renderer/c3DEngine';
import RendererConstant from '../Renderer/RendererConstant';

import { getMaxColorSamplerUnitsCount } from '../Renderer/LayeredMaterial';

import Layer from '../Layer/Layer';
import ColorLayer from '../Layer/ColorLayer';
import ElevationLayer from '../Layer/ElevationLayer';
import GeometryLayer from '../Layer/GeometryLayer';

import Scheduler from './Scheduler/Scheduler';
import Picking from './Picking';
import WMTSSource from '../Source/WMTSSource';
import WMSSource from '../Source/WMSSource';
import WFSSource from '../Source/WFSSource';
import TMSSource from '../Source/TMSSource';
import StaticSource from '../Source/StaticSource';
import FileSource from '../Source/FileSource';

const supportedSource = new Map([
    ['wmts', WMTSSource],
    ['file', FileSource],
    ['wfs', WFSSource],
    ['wms', WMSSource],
    ['tms', TMSSource],
    ['xyz', TMSSource],
    ['static', StaticSource],
]);

export const VIEW_EVENTS = {
    /**
     * Fires when all the layers of the view are considered initialized.
     * Initialized in this context means: all layers are ready to be
     * displayed (no pending network access, no visual improvement to be
     * expected, ...).
     * If you add new layers, the event will be fired again when all
     * layers are ready.
     * @event View#layers-initialized
     * @property type {string} layers-initialized
     */
    LAYERS_INITIALIZED: 'layers-initialized',
};

/**
 * Constructs an Itowns View instance
 *
 * @param {string} crs - The default CRS of Three.js coordinates. Should be a cartesian CRS.
 * @param {HTMLElement} viewerDiv - Where to instanciate the Three.js scene in the DOM
 * @param {Object=} options - Optional properties.
 * @param {?MainLoop} options.mainLoop - {@link MainLoop} instance to use, otherwise a default one will be constructed
 * @param {?(WebGLRenderer|object)} options.renderer - {@link WebGLRenderer} instance to use, otherwise
 * a default one will be constructed. In this case, if options.renderer is an object, it will be used to
 * configure the renderer (see {@link c3DEngine}.  If not present, a new &lt;canvas> will be created and
 * added to viewerDiv (mutually exclusive with mainLoop)
 * @param {?Scene} options.scene3D - {@link Scene} instance to use, otherwise a default one will be constructed
 * @constructor
 */
function View(crs, viewerDiv, options = {}) {
    if (!viewerDiv) {
        throw new Error('Invalid viewerDiv parameter (must non be null/undefined)');
    }

    this.referenceCrs = crs;

    let engine;
    // options.renderer can be 2 separate things:
    //   - an actual renderer (in this case we don't use viewerDiv)
    //   - options for the renderer to be created
    if (options.renderer &amp;&amp; options.renderer.domElement) {
        engine = new c3DEngine(options.renderer);
    } else {
        engine = new c3DEngine(viewerDiv, options.renderer);
    }

    this.mainLoop = options.mainLoop || new MainLoop(new Scheduler(), engine);

    this.scene = options.scene3D || new THREE.Scene();
    if (!options.scene3D) {
        this.scene.autoUpdate = false;
    }

    this.camera = new Camera(
        this.referenceCrs,
        this.mainLoop.gfxEngine.getWindowSize().x,
        this.mainLoop.gfxEngine.getWindowSize().y,
        options);

    this._frameRequesters = { };
    this._layers = [];

    window.addEventListener('resize', () => {
        // If the user gave us a container (&lt;div>) then itowns' size is
        // the container's size. Otherwise we use window' size.
        const newSize = new THREE.Vector2(viewerDiv.clientWidth, viewerDiv.clientHeight);
        this.mainLoop.gfxEngine.onWindowResize(newSize.x, newSize.y);
        this.notifyChange(this.camera.camera3D);
    }, false);

    this._changeSources = new Set();

    if (__DEBUG__) {
        this.isDebugMode = true;
    }

    this._delayedFrameRequesterRemoval = [];

    this._allLayersAreReadyCallback = () => {
        // all layers must be ready
        const allReady = this.getLayers().every(layer => layer.ready);
        if (allReady &amp;&amp;
                this.mainLoop.scheduler.commandsWaitingExecutionCount() == 0 &amp;&amp;
                this.mainLoop.renderingState == RENDERING_PAUSED) {
            this.dispatchEvent({ type: VIEW_EVENTS.LAYERS_INITIALIZED });
            this.removeFrameRequester(MAIN_LOOP_EVENTS.UPDATE_END, this._allLayersAreReadyCallback);
        }
    };
}

View.prototype = Object.create(THREE.EventDispatcher.prototype);
View.prototype.constructor = View;

function _createLayerFromConfig(config) {
    switch (config.type) {
        case 'color':
            return new ColorLayer(config.id, config);
        case 'elevation':
            return new ElevationLayer(config.id, config);
        case 'geometry':
            return new GeometryLayer(config.id, new THREE.Group(), config);
        case 'debug':
            return new Layer(config.id, 'debug', config);
        default:
            throw new Error(`Unknown layer type ${config.type}: please
                specify a valid one`);
    }
}

const _syncGeometryLayerVisibility = function _syncGeometryLayerVisibility(layer, view) {
    if (layer.object3d) {
        layer.object3d.visible = layer.visible;
    }

    if (layer.threejsLayer) {
        if (layer.visible) {
            view.camera.camera3D.layers.enable(layer.threejsLayer);
        } else {
            view.camera.camera3D.layers.disable(layer.threejsLayer);
        }
    }
};

function _preprocessLayer(view, layer, provider, parentLayer) {
    if (!(layer instanceof Layer)) {
        layer = _createLayerFromConfig(layer);
    }

    if (parentLayer &amp;&amp; !layer.extent) {
        layer.extent = parentLayer.extent;
        if (layer.source &amp;&amp; !layer.source.extent) {
            layer.source.extent = parentLayer.extent;
        }
    }

    if (layer.type == 'geometry' || layer.type == 'debug') {
        if (parentLayer || layer.type == 'debug') {
            // layer.threejsLayer *must* be assigned before preprocessing,
            // because TileProvider.preprocessDataLayer function uses it.
            layer.threejsLayer = view.mainLoop.gfxEngine.getUniqueThreejsLayer();
        }
        layer.defineLayerProperty('visible', true, () => _syncGeometryLayerVisibility(layer, view));
        _syncGeometryLayerVisibility(layer, view);
        // Find projection layer, this is projection destination
        layer.projection = view.referenceCrs;
    } else if (layer.source.tileMatrixSet === 'PM') {
        layer.projection = 'EPSG:3857';
    } else {
        layer.projection = parentLayer.extent.crs();
    }

    if (!layer.whenReady) {
        let providerPreprocessing = Promise.resolve();
        if (provider &amp;&amp; provider.preprocessDataLayer) {
            providerPreprocessing = provider.preprocessDataLayer(layer, view, view.mainLoop.scheduler, parentLayer);
            if (!(providerPreprocessing &amp;&amp; providerPreprocessing.then)) {
                providerPreprocessing = Promise.resolve();
            }
        } else if (layer.source) {
            // TODO: move to dataSourceProvider
            // Tempory fix, because sourceFile loads data in his constructor
            // while it should be loaded in the provider
            layer.source.toTexture = layer.type != 'geometry';
            const protocol = layer.source.protocol;
            layer.source = new (supportedSource.get(protocol))(layer.source, layer.projection);
            providerPreprocessing = layer.source.whenReady || providerPreprocessing;
        }

        // the last promise in the chain must return the layer
        layer.whenReady = providerPreprocessing.then(() => {
            layer.ready = true;
            return layer;
        });
    }


    return layer;
}

/**
 * Add layer in viewer.
 * The layer id must be unique.
 *
 * This function calls `preprocessDataLayer` of the relevant provider with this
 * layer and set `layer.whenReady` to a promise that resolves when
 * the preprocessing operation is done. This promise is also returned by
 * `addLayer` allowing to chain call.
 *
 * @example
 * // Add Color Layer
 * view.addLayer({
 *      type: 'elevation',
 *      id: 'iElevation',
 * });
 *
 * // Example to add an OPENSM Layer
 * view.addLayer({
 *   type: 'color',
 *   id: 'OPENSM',
 *   fx: 2.5,
 *   source: {
 *      protocol:   'xyz',
 *      url:  'http://b.tile.openstreetmap.fr/osmfr/${z}/${x}/${y}.png',
 *      format: 'image/png',
 *       attribution : {
 *           name: 'OpenStreetMap',
 *           url: 'http://www.openstreetmap.org/',
 *       },
 *       tileMatrixSet: 'PM',
 *    },
 * });
 *
 * // Add Elevation Layer and do something once it's ready
 * var layer = view.addLayer({
 *      type: 'elevation',
 *      id: 'iElevation',
 * }).then(() => { .... });
 *
 * // One can also attach a callback to the same promise with a layer instance.
 * layer.whenReady.then(() => { ... });
 *
 * @param {LayerOptions|Layer|GeometryLayer} layer
 * @param {Layer=} parentLayer
 * @return {Promise} a promise resolved with the new layer object when it is fully initialized or rejected if any error occurred.
 */
View.prototype.addLayer = function addLayer(layer, parentLayer) {
    return new Promise((resolve, reject) => {
        if (!layer) {
            reject(new Error('layer is undefined'));
            return;
        }
        const duplicate = this.getLayers((l => l.id == layer.id));
        if (duplicate.length > 0) {
            reject(new Error(`Invalid id '${layer.id}': id already used`));
            return;
        }

        const protocol = layer.source ? layer.source.protocol : layer.protocol;
        const provider = this.mainLoop.scheduler.getProtocolProvider(protocol);
        if (layer.protocol &amp;&amp; !provider) {
            reject(new Error(`${layer.protocol} is not a recognized protocol name.`));
            return;
        }
        layer = _preprocessLayer(this, layer, provider, parentLayer);
        if (parentLayer) {
            if (layer.type == 'color') {
                const layerColors = this.getLayers(l => l.type === 'color');

                const sumColorLayers = parentLayer.countColorLayersTextures(...layerColors, layer);

                if (sumColorLayers &lt;= getMaxColorSamplerUnitsCount()) {
                    parentLayer.attach(layer);
                } else {
                    reject(new Error(`Cant add color layer ${layer.id}: the maximum layer is reached`));
                    return;
                }
            } else {
                parentLayer.attach(layer);
            }
        } else {
            if (typeof (layer.update) !== 'function') {
                reject(new Error('Cant add GeometryLayer: missing a update function'));
                return;
            }
            if (typeof (layer.preUpdate) !== 'function') {
                reject(new Error('Cant add GeometryLayer: missing a preUpdate function'));
                return;
            }

            this._layers.push(layer);
        }

        if (layer.object3d &amp;&amp; !layer.object3d.parent &amp;&amp; layer.object3d !== this.scene) {
            this.scene.add(layer.object3d);
        }

        layer.whenReady.then((layer) => {
            this.notifyChange(parentLayer || layer, false);
            if (!this._frameRequesters[MAIN_LOOP_EVENTS.UPDATE_END] ||
                    this._frameRequesters[MAIN_LOOP_EVENTS.UPDATE_END].indexOf(this._allLayersAreReadyCallback) == -1) {
                this.addFrameRequester(MAIN_LOOP_EVENTS.UPDATE_END, this._allLayersAreReadyCallback);
            }
            resolve(layer);
        });
    });
};

/**
 * Notifies the scene it needs to be updated due to changes exterior to the
 * scene itself (e.g. camera movement).
 * non-interactive events (e.g: texture loaded)
 * @param {*} changeSource
 * @param {boolean} needsRedraw - indicates if notified change requires a full scene redraw.
 */
View.prototype.notifyChange = function notifyChange(changeSource = undefined, needsRedraw = true) {
    if (changeSource) {
        this._changeSources.add(changeSource);
    }
    this.mainLoop.scheduleViewUpdate(this, needsRedraw);
};

/**
 * Get all layers, with an optionnal filter applied.
 * The filter method will be called with 2 args:
 *   - 1st: current layer
 *   - 2nd: (optional) the geometry layer to which the current layer is attached
 * @example
 * // get all layers
 * view.getLayers();
 * // get all color layers
 * view.getLayers(layer => layer.type === 'color');
 * // get all elevation layers
 * view.getLayers(layer => layer.type === 'elevation');
 * // get all geometry layers
 * view.getLayers(layer => layer.type === 'geometry');
 * // get one layer with id
 * view.getLayers(layer => layer.id === 'itt');
 * @param {function(Layer):boolean} filter
 * @returns {Array&lt;Layer>}
 */
View.prototype.getLayers = function getLayers(filter) {
    const result = [];
    for (const layer of this._layers) {
        if (!filter || filter(layer)) {
            result.push(layer);
        }
        for (const attached of layer.attachedLayers) {
            if (!filter || filter(attached, layer)) {
                result.push(attached);
            }
        }
    }
    return result;
};

/**
 * @param {Layer} layer
 * @returns {GeometryLayer} the parent layer of the given layer or undefined.
 */
View.prototype.getParentLayer = function getParentLayer(layer) {
    for (const geometryLayer of this._layers) {
        for (const attached of geometryLayer.attachedLayers) {
            if (attached === layer) {
                return geometryLayer;
            }
        }
    }
};

/**
 * @name FrameRequester
 * @function
 *
 * @description
 * Method that will be called each time the &lt;code>MainLoop&lt;/code> updates. This
 * function will be given as parameter the delta (in ms) between this update and
 * the previous one, and whether or not we just started to render again. This
 * update is considered as the "next" update if &lt;code>view.notifyChange&lt;/code>
 * was called during a precedent update. If &lt;code>view.notifyChange&lt;/code> has
 * been called by something else (other micro/macrotask, UI events etc...), then
 * this update is considered as being the "first". It can also receive optional
 * arguments, depending on the attach point of this function.  Currently only
 * &lt;code>BEFORE_LAYER_UPDATE / AFTER_LAYER_UPDATE&lt;/code> attach points provide
 * an additional argument: the layer being updated.
 * &lt;br>&lt;br>
 *
 * This means that if a &lt;code>frameRequester&lt;/code> function wants to animate something, it
 * should keep on calling &lt;code>view.notifyChange&lt;/code> until its task is done.
 * &lt;br>&lt;br>
 *
 * Implementors of &lt;code>frameRequester&lt;/code> should keep in mind that this
 * function will be potentially called at each frame, thus care should be given
 * about performance.
 * &lt;br>&lt;br>
 *
 * Typical frameRequesters are controls, module wanting to animate moves or UI
 * elements etc... Basically anything that would want to call
 * requestAnimationFrame.
 *
 * @param {number} dt
 * @param {boolean} updateLoopRestarted
 * @param {...*} args
 */
/**
 * Add a frame requester to this view.
 *
 * FrameRequesters can activate the MainLoop update by calling view.notifyChange.
 *
 * @param {String} when - decide when the frameRequester should be called during
 * the update cycle. Can be any of {@link MAIN_LOOP_EVENTS}.
 * @param {FrameRequester} frameRequester - this function will be called at each
 * MainLoop update with the time delta between last update, or 0 if the MainLoop
 * has just been relaunched.
 */
View.prototype.addFrameRequester = function addFrameRequester(when, frameRequester) {
    if (typeof frameRequester !== 'function') {
        throw new Error('frameRequester must be a function');
    }

    if (!this._frameRequesters[when]) {
        this._frameRequesters[when] = [frameRequester];
    } else {
        this._frameRequesters[when].push(frameRequester);
    }
};

/**
 * Remove a frameRequester.
 * The effective removal will happen either later; at worst it'll be at
 * the beginning of the next frame.
 *
 * @param {String} when - attach point of this requester. Can be any of
 * {@link MAIN_LOOP_EVENTS}.
 * @param {FrameRequester} frameRequester
 */
View.prototype.removeFrameRequester = function removeFrameRequester(when, frameRequester) {
    const index = this._frameRequesters[when].indexOf(frameRequester);
    if (index >= 0) {
        this._delayedFrameRequesterRemoval.push({ when, frameRequester });
    } else {
        console.error('Invalid call to removeFrameRequester: frameRequester isn\'t registered');
    }
};

View.prototype._executeFrameRequestersRemovals = function _executeFrameRequestersRemovals() {
    for (const toDelete of this._delayedFrameRequesterRemoval) {
        const index = this._frameRequesters[toDelete.when].indexOf(toDelete.frameRequester);
        if (index >= 0) {
            this._frameRequesters[toDelete.when].splice(index, 1);
        } else {
            console.warn('FrameReq has already been removed');
        }
    }
    this._delayedFrameRequesterRemoval.length = 0;
};

/**
 * Execute a frameRequester.
 *
 * @param {String} when - attach point of this (these) requester(s). Can be any
 * of {@link MAIN_LOOP_EVENTS}.
 * @param {Number} dt - delta between this update and the previous one
 * @param {boolean} updateLoopRestarted
 * @param {...*} args - optional arguments
 */
View.prototype.execFrameRequesters = function execFrameRequesters(when, dt, updateLoopRestarted, ...args) {
    if (!this._frameRequesters[when]) {
        return;
    }

    if (this._delayedFrameRequesterRemoval.length > 0) {
        this._executeFrameRequestersRemovals();
    }

    for (const frameRequester of this._frameRequesters[when]) {
        if (frameRequester.update) {
            frameRequester.update(dt, updateLoopRestarted, args);
        } else {
            frameRequester(dt, updateLoopRestarted, args);
        }
    }
};

const _eventCoords = new THREE.Vector2();
/**
 * Extract view coordinates from a mouse-event / touch-event
 * @param {event} event - event can be a MouseEvent or a TouchEvent
 * @param {number} touchIdx - finger index when using a TouchEvent (default: 0)
 * @return {THREE.Vector2} - view coordinates (in pixels, 0-0 = top-left of the View)
 */
View.prototype.eventToViewCoords = function eventToViewCoords(event, touchIdx = 0) {
    if (event.touches === undefined || !event.touches.length) {
        return _eventCoords.set(event.offsetX, event.offsetY);
    } else {
        const br = this.mainLoop.gfxEngine.renderer.domElement.getBoundingClientRect();
        return _eventCoords.set(
            event.touches[touchIdx].clientX - br.x,
            event.touches[touchIdx].clientY - br.y);
    }
};

/**
 * Extract normalized coordinates (NDC) from a mouse-event / touch-event
 * @param {event} event - event can be a MouseEvent or a TouchEvent
 * @param {number} touchIdx - finger index when using a TouchEvent (default: 0)
 * @return {THREE.Vector2} - NDC coordinates (x and y are [-1, 1])
 */
View.prototype.eventToNormalizedCoords = function eventToNormalizedCoords(event, touchIdx = 0) {
    return this.viewToNormalizedCoords(this.eventToViewCoords(event, touchIdx));
};

/**
 * Convert view coordinates to normalized coordinates (NDC)
 * @param {THREE.Vector2} viewCoords (in pixels, 0-0 = top-left of the View)
 * @return {THREE.Vector2} - NDC coordinates (x and y are [-1, 1])
 */
View.prototype.viewToNormalizedCoords = function viewToNormalizedCoords(viewCoords) {
    _eventCoords.x = 2 * (viewCoords.x / this.camera.width) - 1;
    _eventCoords.y = -2 * (viewCoords.y / this.camera.height) + 1;
    return _eventCoords;
};

/**
 * Convert NDC coordinates to view coordinates
 * @param {THREE.Vector2} ndcCoords
 * @return {THREE.Vector2} - view coordinates (in pixels, 0-0 = top-left of the View)
 */
View.prototype.normalizedToViewCoords = function normalizedToViewCoords(ndcCoords) {
    _eventCoords.x = (ndcCoords.x + 1) * 0.5 * this.camera.width;
    _eventCoords.y = (ndcCoords.y - 1) * -0.5 * this.camera.height;
    return _eventCoords;
};

function layerIdToLayer(view, layerId) {
    const lookup = view.getLayers(l => l.id == layerId);
    if (!lookup.length) {
        throw new Error(`Invalid layer id used as where argument (value = ${layerId})`);
    }
    return lookup[0];
}

/**
 * Return objects from some layers/objects3d under the mouse in this view.
 *
 * @param {Object} mouseOrEvt - mouse position in window coordinates (0, 0 = top-left)
 * or MouseEvent or TouchEvent
 * @param {number} radius - picking will happen in a circle centered on mouseOrEvt. Radius
 * is the radius of this circle, in pixels
 * @param {...*} where - where to look for objects. Can be either: empty (= look
 * in all layers with type == 'geometry'), layer ids or layers or a mix of all
 * the above.
 * @return {Array} - an array of objects. Each element contains at least an object
 * property which is the Object3D under the cursor. Then depending on the queried
 * layer/source, there may be additionnal properties (coming from THREE.Raycaster
 * for instance).
 *
 * @example
 * view.pickObjectsAt({ x, y })
 * view.pickObjectsAt({ x, y }, 1, 'wfsBuilding')
 * view.pickObjectsAt({ x, y }, 3, 'wfsBuilding', myLayer)
 */
View.prototype.pickObjectsAt = function pickObjectsAt(mouseOrEvt, radius, ...where) {
    const results = [];
    const sources = where.length == 0 ?
        this.getLayers(l => l.type == 'geometry') :
        [...where];
    const mouse = (mouseOrEvt instanceof Event) ? this.eventToViewCoords(mouseOrEvt) : mouseOrEvt;
    radius = radius || 0;

    for (const source of sources) {
        if (source instanceof Layer ||
            typeof (source) === 'string') {
            const layer = (typeof (source) === 'string') ?
                layerIdToLayer(this, source) :
                source;

            const parentLayer = this.getParentLayer(layer);
            if (!parentLayer) {
                const sp = layer.pickObjectsAt(this, mouse, radius);
                // warning: sp might be very large, so we can't use '...sp' (we'll hit
                // 'javascript maximum call stack size exceeded' error) nor
                // Array.prototype.push.apply(result, sp)
                for (let i = 0; i &lt; sp.length; i++) {
                    results.push(sp[i]);
                }
            } else {
                // raycast using parent layer object3d
                const obj = Picking.pickObjectsAt(
                    this,
                    mouse,
                    radius,
                    parentLayer.object3d);

                // then filter the results
                for (const o of obj) {
                    if (o.layer === layer) {
                        results.push(o);
                    }
                }
            }
        } else if (source instanceof THREE.Object3D) {
            Picking.pickObjectsAt(
                this,
                mouse,
                radius,
                source,
                results);
        } else {
            throw new Error(`Invalid where arg (value = ${where}). Expected layers, layer ids or Object3Ds`);
        }
    }

    return results;
};

View.prototype.readDepthBuffer = function readDepthBuffer(x, y, width, height) {
    const g = this.mainLoop.gfxEngine;
    const currentWireframe = this.tileLayer.wireframe;
    const currentOpacity = this.tileLayer.opacity;
    const currentVisibility = this.tileLayer.visible;
    if (currentWireframe) {
        this.tileLayer.wireframe = false;
    }
    if (currentOpacity &lt; 1.0) {
        this.tileLayer.opacity = 1.0;
    }
    if (!currentVisibility) {
        this.tileLayer.visible = true;
    }

    const restore = this.tileLayer.level0Nodes.map(n => n.pushRenderState(RendererConstant.DEPTH));
    const buffer = g.renderViewToBuffer(
        { camera: this.camera, scene: this.tileLayer.object3d },
        { x, y, width, height });
    restore.forEach(r => r());

    if (this.tileLayer.wireframe !== currentWireframe) {
        this.tileLayer.wireframe = currentWireframe;
    }
    if (this.tileLayer.opacity !== currentOpacity) {
        this.tileLayer.opacity = currentOpacity;
    }
    if (this.tileLayer.visible !== currentVisibility) {
        this.tileLayer.visible = currentVisibility;
    }

    return buffer;
};

const matrix = new THREE.Matrix4();
const screen = new THREE.Vector2();
const ray = new THREE.Ray();
const direction = new THREE.Vector3();

/**
 * Returns the world position (view's crs: referenceCrs) under view coordinates.
 * This position is computed with depth buffer.
 *
 * @param      {THREE.Vector2}  mouse  position in view coordinates (in pixel), if it's null so it's view's center.
 * @param      {THREE.Vector3}  [target=THREE.Vector3()] target. the result will be copied into this Vector3. If not present a new one will be created.
 * @return     {THREE.Vector3}  the world position in view's crs: referenceCrs.
 */

View.prototype.getPickingPositionFromDepth = function fnGetPickingPositionFromDepth(mouse, target = new THREE.Vector3()) {
    if (!this.tileLayer || this.tileLayer.level0Nodes.length == 0 || (!this.tileLayer.level0Nodes[0])) {
        target = undefined;
        return;
    }
    const l = this.mainLoop;
    const viewPaused = l.scheduler.commandsWaitingExecutionCount() == 0 &amp;&amp; l.renderingState == RENDERING_PAUSED;
    const g = l.gfxEngine;
    const dim = g.getWindowSize();
    const camera = this.camera.camera3D;

    mouse = mouse || dim.clone().multiplyScalar(0.5);
    mouse.x = Math.floor(mouse.x);
    mouse.y = Math.floor(mouse.y);

    // Prepare state
    const prev = camera.layers.mask;
    camera.layers.mask = 1 &lt;&lt; this.tileLayer.threejsLayer;

    // Render/Read to buffer
    let buffer;
    if (viewPaused) {
        this._fullSizeDepthBuffer = this._fullSizeDepthBuffer || this.readDepthBuffer(0, 0, dim.x, dim.y);
        const id = ((dim.y - mouse.y - 1) * dim.x + mouse.x) * 4;
        buffer = this._fullSizeDepthBuffer.slice(id, id + 4);
    } else {
        buffer = this.readDepthBuffer(mouse.x, mouse.y, 1, 1);
    }

    screen.x = (mouse.x / dim.x) * 2 - 1;
    screen.y = -(mouse.y / dim.y) * 2 + 1;

    // Origin
    ray.origin.copy(camera.position);

    // Direction
    ray.direction.set(screen.x, screen.y, 0.5);
    // Unproject
    matrix.multiplyMatrices(camera.matrixWorld, matrix.getInverse(camera.projectionMatrix));
    ray.direction.applyMatrix4(matrix);
    ray.direction.sub(ray.origin);

    direction.set(0, 0, 1.0);
    direction.applyMatrix4(matrix);
    direction.sub(ray.origin);

    const angle = direction.angleTo(ray.direction);
    const orthoZ = g.depthBufferRGBAValueToOrthoZ(buffer, camera);
    const length = orthoZ / Math.cos(angle);

    target.addVectors(camera.position, ray.direction.setLength(length));

    camera.layers.mask = prev;

    if (target.length() > 10000000) { return undefined; }

    return target;
};

export default View;
</code></pre>
        </article>
    </section>




    </div>

    <nav>
        <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="ColorLayer.html">ColorLayer</a><ul class='methods'><li data-type='method'><a href="ColorLayer.html#defineLayerProperty">defineLayerProperty</a></li></ul></li><li><a href="Coordinates.html">Coordinates</a><ul class='methods'><li data-type='method'><a href="Coordinates.html#altitude">altitude</a></li><li data-type='method'><a href="Coordinates.html#as">as</a></li><li data-type='method'><a href="Coordinates.html#latitude">latitude</a></li><li data-type='method'><a href="Coordinates.html#longitude">longitude</a></li><li data-type='method'><a href="Coordinates.html#offsetInExtent">offsetInExtent</a></li><li data-type='method'><a href="Coordinates.html#setAltitude">setAltitude</a></li><li data-type='method'><a href="Coordinates.html#x">x</a></li><li data-type='method'><a href="Coordinates.html#xyz">xyz</a></li><li data-type='method'><a href="Coordinates.html#y">y</a></li><li data-type='method'><a href="Coordinates.html#z">z</a></li></ul></li><li><a href="ElevationLayer.html">ElevationLayer</a><ul class='methods'><li data-type='method'><a href="ElevationLayer.html#defineLayerProperty">defineLayerProperty</a></li></ul></li><li><a href="Extent.html">Extent</a><ul class='methods'><li data-type='method'><a href="Extent.html#intersect">intersect</a></li><li data-type='method'><a href="Extent.html#intersectsExtent">intersectsExtent</a></li><li data-type='method'><a href="Extent.html#isPointInside">isPointInside</a></li><li data-type='method'><a href="Extent.html#subdivision">subdivision</a></li></ul></li><li><a href="FileSource.html">FileSource</a><ul class='methods'><li data-type='method'><a href="FileSource.html#extentInsideLimit">extentInsideLimit</a></li><li data-type='method'><a href="FileSource.html#extentsInsideLimit">extentsInsideLimit</a></li><li data-type='method'><a href="FileSource.html#urlFromExtent">urlFromExtent</a></li></ul></li><li><a href="FirstPersonControls.html">FirstPersonControls</a><ul class='methods'><li data-type='method'><a href="FirstPersonControls.html#reset">reset</a></li><li data-type='method'><a href="FirstPersonControls.html#update">update</a></li></ul></li><li><a href="GeometryLayer.html">GeometryLayer</a><ul class='methods'><li data-type='method'><a href="GeometryLayer.html#attach">attach</a></li><li data-type='method'><a href="GeometryLayer.html#changeOpacity">changeOpacity</a></li><li data-type='method'><a href="GeometryLayer.html#defineLayerProperty">defineLayerProperty</a></li><li data-type='method'><a href="GeometryLayer.html#detach">detach</a></li><li data-type='method'><a href="GeometryLayer.html#pickObjectsAt">pickObjectsAt</a></li></ul></li><li><a href="GlobeControls.html">GlobeControls</a><ul class='methods'><li data-type='method'><a href="GlobeControls.html#getCameraCoordinate">getCameraCoordinate</a></li><li data-type='method'><a href="GlobeControls.html#getCameraOrientation">getCameraOrientation</a></li><li data-type='method'><a href="GlobeControls.html#getCameraTargetGeoPosition">getCameraTargetGeoPosition</a></li><li data-type='method'><a href="GlobeControls.html#getCameraTargetPosition">getCameraTargetPosition</a></li><li data-type='method'><a href="GlobeControls.html#getHeading">getHeading</a></li><li data-type='method'><a href="GlobeControls.html#getLookAtCoordinate">getLookAtCoordinate</a></li><li data-type='method'><a href="GlobeControls.html#getRange">getRange</a></li><li data-type='method'><a href="GlobeControls.html#getScale">getScale</a></li><li data-type='method'><a href="GlobeControls.html#getTilt">getTilt</a></li><li data-type='method'><a href="GlobeControls.html#getZoom">getZoom</a></li><li data-type='method'><a href="GlobeControls.html#isAnimationEnabled">isAnimationEnabled</a></li><li data-type='method'><a href="GlobeControls.html#lookAtCoordinate">lookAtCoordinate</a></li><li data-type='method'><a href="GlobeControls.html#metersToPixels">metersToPixels</a></li><li data-type='method'><a href="GlobeControls.html#pan">pan</a></li><li data-type='method'><a href="GlobeControls.html#pickGeoPosition">pickGeoPosition</a></li><li data-type='method'><a href="GlobeControls.html#pixelsToDegrees">pixelsToDegrees</a></li><li data-type='method'><a href="GlobeControls.html#pixelsToMeters">pixelsToMeters</a></li><li data-type='method'><a href="GlobeControls.html#setAnimationEnabled">setAnimationEnabled</a></li><li data-type='method'><a href="GlobeControls.html#setCameraTargetGeoPosition">setCameraTargetGeoPosition</a></li><li data-type='method'><a href="GlobeControls.html#setCameraTargetGeoPositionAdvanced">setCameraTargetGeoPositionAdvanced</a></li><li data-type='method'><a href="GlobeControls.html#setHeading">setHeading</a></li><li data-type='method'><a href="GlobeControls.html#setOrbitalPosition">setOrbitalPosition</a></li><li data-type='method'><a href="GlobeControls.html#setRange">setRange</a></li><li data-type='method'><a href="GlobeControls.html#setScale">setScale</a></li><li data-type='method'><a href="GlobeControls.html#setTilt">setTilt</a></li><li data-type='method'><a href="GlobeControls.html#setZoom">setZoom</a></li></ul></li><li><a href="GlobeLayer.html">GlobeLayer</a><ul class='methods'><li data-type='method'><a href="GlobeLayer.html#attach">attach</a></li><li data-type='method'><a href="GlobeLayer.html#changeOpacity">changeOpacity</a></li><li data-type='method'><a href="GlobeLayer.html#defineLayerProperty">defineLayerProperty</a></li><li data-type='method'><a href="GlobeLayer.html#detach">detach</a></li><li data-type='method'><a href="GlobeLayer.html#pickObjectsAt">pickObjectsAt</a></li><li data-type='method'><a href="GlobeLayer.html#preUpdate">preUpdate</a></li><li data-type='method'><a href="GlobeLayer.html#subdivideNode">subdivideNode</a></li><li data-type='method'><a href="GlobeLayer.html#subdivision">subdivision</a></li><li data-type='method'><a href="GlobeLayer.html#update">update</a></li></ul></li><li><a href="GlobeView.html">GlobeView</a><ul class='methods'><li data-type='method'><a href="GlobeView.html#addFrameRequester">addFrameRequester</a></li><li data-type='method'><a href="GlobeView.html#addLayer">addLayer</a></li><li data-type='method'><a href="GlobeView.html#eventToNormalizedCoords">eventToNormalizedCoords</a></li><li data-type='method'><a href="GlobeView.html#eventToViewCoords">eventToViewCoords</a></li><li data-type='method'><a href="GlobeView.html#execFrameRequesters">execFrameRequesters</a></li><li data-type='method'><a href="GlobeView.html#getLayers">getLayers</a></li><li data-type='method'><a href="GlobeView.html#getParentLayer">getParentLayer</a></li><li data-type='method'><a href="GlobeView.html#getPickingPositionFromDepth">getPickingPositionFromDepth</a></li><li data-type='method'><a href="GlobeView.html#normalizedToViewCoords">normalizedToViewCoords</a></li><li data-type='method'><a href="GlobeView.html#notifyChange">notifyChange</a></li><li data-type='method'><a href="GlobeView.html#pickObjectsAt">pickObjectsAt</a></li><li data-type='method'><a href="GlobeView.html#removeFrameRequester">removeFrameRequester</a></li><li data-type='method'><a href="GlobeView.html#removeLayer">removeLayer</a></li><li data-type='method'><a href="GlobeView.html#viewToNormalizedCoords">viewToNormalizedCoords</a></li></ul></li><li><a href="InfoTiledGeometryLayer.html">InfoTiledGeometryLayer</a></li><li><a href="Layer.html">Layer</a><ul class='methods'><li data-type='method'><a href="Layer.html#defineLayerProperty">defineLayerProperty</a></li></ul></li><li><a href="OBB.html">OBB</a><ul class='methods'><li data-type='method'><a href="OBB.html#.extentToOBB">extentToOBB</a></li><li data-type='method'><a href="OBB.html#clone">clone</a></li><li data-type='method'><a href="OBB.html#copy">copy</a></li><li data-type='method'><a href="OBB.html#isSphereAboveXYBox">isSphereAboveXYBox</a></li><li data-type='method'><a href="OBB.html#toPoints">toPoints</a></li><li data-type='method'><a href="OBB.html#update">update</a></li><li data-type='method'><a href="OBB.html#updateZ">updateZ</a></li></ul></li><li><a href="OrientedImageCamera.html">OrientedImageCamera</a></li><li><a href="PanoramaLayer.html">PanoramaLayer</a><ul class='methods'><li data-type='method'><a href="PanoramaLayer.html#attach">attach</a></li><li data-type='method'><a href="PanoramaLayer.html#changeOpacity">changeOpacity</a></li><li data-type='method'><a href="PanoramaLayer.html#defineLayerProperty">defineLayerProperty</a></li><li data-type='method'><a href="PanoramaLayer.html#detach">detach</a></li><li data-type='method'><a href="PanoramaLayer.html#pickObjectsAt">pickObjectsAt</a></li><li data-type='method'><a href="PanoramaLayer.html#preUpdate">preUpdate</a></li><li data-type='method'><a href="PanoramaLayer.html#subdivideNode">subdivideNode</a></li><li data-type='method'><a href="PanoramaLayer.html#subdivision">subdivision</a></li><li data-type='method'><a href="PanoramaLayer.html#update">update</a></li></ul></li><li><a href="PlanarControls.html">PlanarControls</a></li><li><a href="PlanarLayer.html">PlanarLayer</a><ul class='methods'><li data-type='method'><a href="PlanarLayer.html#attach">attach</a></li><li data-type='method'><a href="PlanarLayer.html#changeOpacity">changeOpacity</a></li><li data-type='method'><a href="PlanarLayer.html#defineLayerProperty">defineLayerProperty</a></li><li data-type='method'><a href="PlanarLayer.html#detach">detach</a></li><li data-type='method'><a href="PlanarLayer.html#pickObjectsAt">pickObjectsAt</a></li><li data-type='method'><a href="PlanarLayer.html#preUpdate">preUpdate</a></li><li data-type='method'><a href="PlanarLayer.html#subdivideNode">subdivideNode</a></li><li data-type='method'><a href="PlanarLayer.html#subdivision">subdivision</a></li><li data-type='method'><a href="PlanarLayer.html#update">update</a></li></ul></li><li><a href="Scheduler.html">Scheduler</a><ul class='methods'><li data-type='method'><a href="Scheduler.html#addProtocolProvider">addProtocolProvider</a></li><li data-type='method'><a href="Scheduler.html#getProtocolProvider">getProtocolProvider</a></li></ul></li><li><a href="Source.html">Source</a><ul class='methods'><li data-type='method'><a href="Source.html#extentInsideLimit">extentInsideLimit</a></li><li data-type='method'><a href="Source.html#extentsInsideLimit">extentsInsideLimit</a></li><li data-type='method'><a href="Source.html#urlFromExtent">urlFromExtent</a></li></ul></li><li><a href="StateControl.html">StateControl</a><ul class='methods'><li data-type='method'><a href="StateControl.html#inputToState">inputToState</a></li><li data-type='method'><a href="StateControl.html#touchToState">touchToState</a></li></ul></li><li><a href="StaticSource.html">StaticSource</a><ul class='methods'><li data-type='method'><a href="StaticSource.html#extentInsideLimit">extentInsideLimit</a></li><li data-type='method'><a href="StaticSource.html#extentsInsideLimit">extentsInsideLimit</a></li><li data-type='method'><a href="StaticSource.html#urlFromExtent">urlFromExtent</a></li></ul></li><li><a href="TiledGeometryLayer.html">TiledGeometryLayer</a><ul class='methods'><li data-type='method'><a href="TiledGeometryLayer.html#.hasEnoughTexturesToSubdivide">hasEnoughTexturesToSubdivide</a></li><li data-type='method'><a href="TiledGeometryLayer.html#attach">attach</a></li><li data-type='method'><a href="TiledGeometryLayer.html#changeOpacity">changeOpacity</a></li><li data-type='method'><a href="TiledGeometryLayer.html#defineLayerProperty">defineLayerProperty</a></li><li data-type='method'><a href="TiledGeometryLayer.html#detach">detach</a></li><li data-type='method'><a href="TiledGeometryLayer.html#pickObjectsAt">pickObjectsAt</a></li><li data-type='method'><a href="TiledGeometryLayer.html#preUpdate">preUpdate</a></li><li data-type='method'><a href="TiledGeometryLayer.html#subdivideNode">subdivideNode</a></li><li data-type='method'><a href="TiledGeometryLayer.html#update">update</a></li></ul></li><li><a href="TMSSource.html">TMSSource</a><ul class='methods'><li data-type='method'><a href="TMSSource.html#extentInsideLimit">extentInsideLimit</a></li><li data-type='method'><a href="TMSSource.html#extentsInsideLimit">extentsInsideLimit</a></li><li data-type='method'><a href="TMSSource.html#urlFromExtent">urlFromExtent</a></li></ul></li><li><a href="View.html">View</a><ul class='methods'><li data-type='method'><a href="View.html#addFrameRequester">addFrameRequester</a></li><li data-type='method'><a href="View.html#addLayer">addLayer</a></li><li data-type='method'><a href="View.html#eventToNormalizedCoords">eventToNormalizedCoords</a></li><li data-type='method'><a href="View.html#eventToViewCoords">eventToViewCoords</a></li><li data-type='method'><a href="View.html#execFrameRequesters">execFrameRequesters</a></li><li data-type='method'><a href="View.html#getLayers">getLayers</a></li><li data-type='method'><a href="View.html#getParentLayer">getParentLayer</a></li><li data-type='method'><a href="View.html#getPickingPositionFromDepth">getPickingPositionFromDepth</a></li><li data-type='method'><a href="View.html#normalizedToViewCoords">normalizedToViewCoords</a></li><li data-type='method'><a href="View.html#notifyChange">notifyChange</a></li><li data-type='method'><a href="View.html#pickObjectsAt">pickObjectsAt</a></li><li data-type='method'><a href="View.html#removeFrameRequester">removeFrameRequester</a></li><li data-type='method'><a href="View.html#viewToNormalizedCoords">viewToNormalizedCoords</a></li></ul></li><li><a href="WFSSource.html">WFSSource</a><ul class='methods'><li data-type='method'><a href="WFSSource.html#extentInsideLimit">extentInsideLimit</a></li><li data-type='method'><a href="WFSSource.html#extentsInsideLimit">extentsInsideLimit</a></li><li data-type='method'><a href="WFSSource.html#urlFromExtent">urlFromExtent</a></li></ul></li><li><a href="WMSSource.html">WMSSource</a><ul class='methods'><li data-type='method'><a href="WMSSource.html#extentInsideLimit">extentInsideLimit</a></li><li data-type='method'><a href="WMSSource.html#extentsInsideLimit">extentsInsideLimit</a></li><li data-type='method'><a href="WMSSource.html#urlFromExtent">urlFromExtent</a></li></ul></li><li><a href="WMTSSource.html">WMTSSource</a><ul class='methods'><li data-type='method'><a href="WMTSSource.html#extentInsideLimit">extentInsideLimit</a></li><li data-type='method'><a href="WMTSSource.html#extentsInsideLimit">extentsInsideLimit</a></li><li data-type='method'><a href="WMTSSource.html#urlFromExtent">urlFromExtent</a></li></ul></li></ul><h3>Modules</h3><ul><li><a href="module-Cache.html">Cache</a><ul class='methods'><li data-type='method'><a href="module-Cache.html#.clear">clear</a></li><li data-type='method'><a href="module-Cache.html#.delete">delete</a></li><li data-type='method'><a href="module-Cache.html#.flush">flush</a></li><li data-type='method'><a href="module-Cache.html#.get">get</a></li><li data-type='method'><a href="module-Cache.html#.set">set</a></li></ul></li><li><a href="module-CameraCalibrationParser.html">CameraCalibrationParser</a><ul class='methods'><li data-type='method'><a href="module-CameraCalibrationParser.html#.parse">parse</a></li></ul></li><li><a href="module-CameraUtils.html">CameraUtils</a><ul class='methods'><li data-type='method'><a href="module-CameraUtils.html#.animateCameraToLookAtTarget">animateCameraToLookAtTarget</a></li><li data-type='method'><a href="module-CameraUtils.html#.getDiffParams">getDiffParams</a></li><li data-type='method'><a href="module-CameraUtils.html#.getTransformCameraLookingAtTarget">getTransformCameraLookingAtTarget</a></li><li data-type='method'><a href="module-CameraUtils.html#.sequenceAnimationsToLookAtTarget">sequenceAnimationsToLookAtTarget</a></li><li data-type='method'><a href="module-CameraUtils.html#.stop">stop</a></li><li data-type='method'><a href="module-CameraUtils.html#.transformCameraToLookAtTarget">transformCameraToLookAtTarget</a></li></ul></li><li><a href="module-Feature2Mesh.html">Feature2Mesh</a><ul class='methods'><li data-type='method'><a href="module-Feature2Mesh.html#.convert">convert</a></li></ul></li><li><a href="module-GeoJsonParser.html">GeoJsonParser</a><ul class='methods'><li data-type='method'><a href="module-GeoJsonParser.html#.parse">parse</a></li></ul></li><li><a href="module-GpxParser.html">GpxParser</a><ul class='methods'><li data-type='method'><a href="module-GpxParser.html#~parse">parse</a></li></ul></li><li><a href="module-OrientationUtils.html">OrientationUtils</a><ul class='methods'><li data-type='method'><a href="module-OrientationUtils.html#~globeQuaternionFromAttitude">globeQuaternionFromAttitude</a></li><li data-type='method'><a href="module-OrientationUtils.html#~localQuaternionFromAttitude">localQuaternionFromAttitude</a></li><li data-type='method'><a href="module-OrientationUtils.html#~quaternionFromAttitude">quaternionFromAttitude</a></li></ul></li><li><a href="module-URLBuilder.html">URLBuilder</a><ul class='methods'><li data-type='method'><a href="module-URLBuilder.html#.bbox">bbox</a></li><li data-type='method'><a href="module-URLBuilder.html#.xyz">xyz</a></li></ul></li><li><a href="module-VectorTileParser.html">VectorTileParser</a><ul class='methods'><li data-type='method'><a href="module-VectorTileParser.html#.parse">parse</a></li></ul></li></ul><h3>Events</h3><ul><li><a href="ColorLayer.html#event:opacity-property-changed">opacity-property-changed</a></li><li><a href="ColorLayer.html#event:sequence-property-changed">sequence-property-changed</a></li><li><a href="ColorLayer.html#event:visible-property-changed">visible-property-changed</a></li><li><a href="GeometryLayer.html#event:opacity-property-changed">opacity-property-changed</a></li><li><a href="GlobeControls.html#event:camera-target-changed">camera-target-changed</a></li><li><a href="GlobeControls.html#event:orientation-changed">orientation-changed</a></li><li><a href="GlobeControls.html#event:pan-changed">pan-changed</a></li><li><a href="GlobeControls.html#event:range-changed">range-changed</a></li><li><a href="GlobeLayer.html#event:opacity-property-changed">opacity-property-changed</a></li><li><a href="GlobeView.html#event:initialized">initialized</a></li><li><a href="GlobeView.html#event:layer-added">layer-added</a></li><li><a href="GlobeView.html#event:layer-removed">layer-removed</a></li><li><a href="GlobeView.html#event:layers-initialized">layers-initialized</a></li><li><a href="GlobeView.html#event:layers-order-changed">layers-order-changed</a></li><li><a href="PanoramaLayer.html#event:opacity-property-changed">opacity-property-changed</a></li><li><a href="PlanarLayer.html#event:opacity-property-changed">opacity-property-changed</a></li><li><a href="TiledGeometryLayer.html#event:opacity-property-changed">opacity-property-changed</a></li><li><a href="View.html#event:layers-initialized">layers-initialized</a></li></ul><h3>Interfaces</h3><ul><li><a href="Provider.html">Provider</a><ul class='methods'><li data-type='method'><a href="Provider.html#executeCommand">executeCommand</a></li><li data-type='method'><a href="Provider.html#preprocessDataLayer">preprocessDataLayer</a></li></ul></li></ul><h3>Global</h3><ul><li><a href="global.html#c">c</a></li><li><a href="global.html#CARDINAL">CARDINAL</a></li><li><a href="global.html#CONTROL_EVENTS">CONTROL_EVENTS</a></li><li><a href="global.html#coord">coord</a></li><li><a href="global.html#featureToMesh">featureToMesh</a></li><li><a href="global.html#FrameRequester">FrameRequester</a></li><li><a href="global.html#GLOBE_VIEW_EVENTS">GLOBE_VIEW_EVENTS</a></li><li><a href="global.html#MAIN_LOOP_EVENTS">MAIN_LOOP_EVENTS</a></li><li><a href="global.html#moveLayerDown">moveLayerDown</a></li><li><a href="global.html#moveLayerToIndex">moveLayerToIndex</a></li><li><a href="global.html#moveLayerUp">moveLayerUp</a></li></ul>
    </nav>

    <br class="clear">

    <footer>
        Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Thu Nov 15 2018 14:52:38 GMT+0000 (Coordinated Universal Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
    </footer>

    <script> prettyPrint(); </script>
    <script src="scripts/linenumber.js"> </script>
</body>
</html>
